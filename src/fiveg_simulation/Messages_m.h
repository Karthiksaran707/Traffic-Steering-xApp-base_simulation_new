//
// Generated file, do not edit! Created by opp_msgtool 6.3 from src/Messages.msg.
//

#ifndef __MESSAGES_M_H
#define __MESSAGES_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0603
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

class InitialAccessRequest;
class InitialAccessResponse;
class RegistrationRequest;
class RegistrationResponse;
class DataPacket;
class DataAck;
class MeasurementReport;
class HandoverCommand;
class HandoverAck;
class LoadReport;
class LoadBalanceCommand;
class PolicyUpdate;
/**
 * Class generated from <tt>src/Messages.msg:8</tt> by opp_msgtool.
 * <pre>
 * // Phase 1: Initial Access Messages
 * message InitialAccessRequest
 * {
 *     int ueId;               // Unique UE identifier
 *     double signalStrength;  // Signal strength at UE
 *     double posX;            // UE X position
 *     double posY;            // UE Y position
 * }
 * </pre>
 */
class InitialAccessRequest : public ::omnetpp::cMessage
{
  protected:
    int ueId = 0;
    double signalStrength = 0;
    double posX = 0;
    double posY = 0;

  private:
    void copy(const InitialAccessRequest& other);

  protected:
    bool operator==(const InitialAccessRequest&) = delete;

  public:
    InitialAccessRequest(const char *name=nullptr, short kind=0);
    InitialAccessRequest(const InitialAccessRequest& other);
    virtual ~InitialAccessRequest();
    InitialAccessRequest& operator=(const InitialAccessRequest& other);
    virtual InitialAccessRequest *dup() const override {return new InitialAccessRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getUeId() const;
    virtual void setUeId(int ueId);

    virtual double getSignalStrength() const;
    virtual void setSignalStrength(double signalStrength);

    virtual double getPosX() const;
    virtual void setPosX(double posX);

    virtual double getPosY() const;
    virtual void setPosY(double posY);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InitialAccessRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InitialAccessRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:16</tt> by opp_msgtool.
 * <pre>
 * message InitialAccessResponse
 * {
 *     int ueId;
 *     int gNBId;
 *     bool accepted;              // Whether connection is accepted
 *     int allocatedRBs;           // Allocated Resource Blocks
 *     int timeSlot;               // Allocated time slot
 *     int frequencySlot;          // Allocated frequency slot
 * }
 * </pre>
 */
class InitialAccessResponse : public ::omnetpp::cMessage
{
  protected:
    int ueId = 0;
    int gNBId = 0;
    bool accepted = false;
    int allocatedRBs = 0;
    int timeSlot = 0;
    int frequencySlot = 0;

  private:
    void copy(const InitialAccessResponse& other);

  protected:
    bool operator==(const InitialAccessResponse&) = delete;

  public:
    InitialAccessResponse(const char *name=nullptr, short kind=0);
    InitialAccessResponse(const InitialAccessResponse& other);
    virtual ~InitialAccessResponse();
    InitialAccessResponse& operator=(const InitialAccessResponse& other);
    virtual InitialAccessResponse *dup() const override {return new InitialAccessResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getUeId() const;
    virtual void setUeId(int ueId);

    virtual int getGNBId() const;
    virtual void setGNBId(int gNBId);

    virtual bool getAccepted() const;
    virtual void setAccepted(bool accepted);

    virtual int getAllocatedRBs() const;
    virtual void setAllocatedRBs(int allocatedRBs);

    virtual int getTimeSlot() const;
    virtual void setTimeSlot(int timeSlot);

    virtual int getFrequencySlot() const;
    virtual void setFrequencySlot(int frequencySlot);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InitialAccessResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InitialAccessResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:26</tt> by opp_msgtool.
 * <pre>
 * message RegistrationRequest
 * {
 *     int ueId;
 *     int gNBId;
 *     string imsi;                // International Mobile Subscriber Identity
 * }
 * </pre>
 */
class RegistrationRequest : public ::omnetpp::cMessage
{
  protected:
    int ueId = 0;
    int gNBId = 0;
    omnetpp::opp_string imsi;

  private:
    void copy(const RegistrationRequest& other);

  protected:
    bool operator==(const RegistrationRequest&) = delete;

  public:
    RegistrationRequest(const char *name=nullptr, short kind=0);
    RegistrationRequest(const RegistrationRequest& other);
    virtual ~RegistrationRequest();
    RegistrationRequest& operator=(const RegistrationRequest& other);
    virtual RegistrationRequest *dup() const override {return new RegistrationRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getUeId() const;
    virtual void setUeId(int ueId);

    virtual int getGNBId() const;
    virtual void setGNBId(int gNBId);

    virtual const char * getImsi() const;
    virtual void setImsi(const char * imsi);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RegistrationRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RegistrationRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:33</tt> by opp_msgtool.
 * <pre>
 * message RegistrationResponse
 * {
 *     int ueId;
 *     bool authenticated;
 *     string ipAddress;           // Assigned IP address
 *     int sessionId;
 * }
 * </pre>
 */
class RegistrationResponse : public ::omnetpp::cMessage
{
  protected:
    int ueId = 0;
    bool authenticated = false;
    omnetpp::opp_string ipAddress;
    int sessionId = 0;

  private:
    void copy(const RegistrationResponse& other);

  protected:
    bool operator==(const RegistrationResponse&) = delete;

  public:
    RegistrationResponse(const char *name=nullptr, short kind=0);
    RegistrationResponse(const RegistrationResponse& other);
    virtual ~RegistrationResponse();
    RegistrationResponse& operator=(const RegistrationResponse& other);
    virtual RegistrationResponse *dup() const override {return new RegistrationResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getUeId() const;
    virtual void setUeId(int ueId);

    virtual bool getAuthenticated() const;
    virtual void setAuthenticated(bool authenticated);

    virtual const char * getIpAddress() const;
    virtual void setIpAddress(const char * ipAddress);

    virtual int getSessionId() const;
    virtual void setSessionId(int sessionId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RegistrationResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RegistrationResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:42</tt> by opp_msgtool.
 * <pre>
 * // Phase 2: Data Transmission Messages
 * message DataPacket
 * {
 *     int ueId;
 *     int gNBId;
 *     int sessionId;
 *     int sequenceNumber;
 *     int packetSize;             // Size in bytes
 *     double timestamp;
 *     string payload;
 *     string destinationIP;
 *     string sourceIP;
 * }
 * </pre>
 */
class DataPacket : public ::omnetpp::cMessage
{
  protected:
    int ueId = 0;
    int gNBId = 0;
    int sessionId = 0;
    int sequenceNumber = 0;
    int packetSize = 0;
    double timestamp = 0;
    omnetpp::opp_string payload;
    omnetpp::opp_string destinationIP;
    omnetpp::opp_string sourceIP;

  private:
    void copy(const DataPacket& other);

  protected:
    bool operator==(const DataPacket&) = delete;

  public:
    DataPacket(const char *name=nullptr, short kind=0);
    DataPacket(const DataPacket& other);
    virtual ~DataPacket();
    DataPacket& operator=(const DataPacket& other);
    virtual DataPacket *dup() const override {return new DataPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getUeId() const;
    virtual void setUeId(int ueId);

    virtual int getGNBId() const;
    virtual void setGNBId(int gNBId);

    virtual int getSessionId() const;
    virtual void setSessionId(int sessionId);

    virtual int getSequenceNumber() const;
    virtual void setSequenceNumber(int sequenceNumber);

    virtual int getPacketSize() const;
    virtual void setPacketSize(int packetSize);

    virtual double getTimestamp() const;
    virtual void setTimestamp(double timestamp);

    virtual const char * getPayload() const;
    virtual void setPayload(const char * payload);

    virtual const char * getDestinationIP() const;
    virtual void setDestinationIP(const char * destinationIP);

    virtual const char * getSourceIP() const;
    virtual void setSourceIP(const char * sourceIP);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const DataPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, DataPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:55</tt> by opp_msgtool.
 * <pre>
 * message DataAck
 * {
 *     int ueId;
 *     int sequenceNumber;
 *     bool success;
 *     double latency;
 * }
 * </pre>
 */
class DataAck : public ::omnetpp::cMessage
{
  protected:
    int ueId = 0;
    int sequenceNumber = 0;
    bool success = false;
    double latency = 0;

  private:
    void copy(const DataAck& other);

  protected:
    bool operator==(const DataAck&) = delete;

  public:
    DataAck(const char *name=nullptr, short kind=0);
    DataAck(const DataAck& other);
    virtual ~DataAck();
    DataAck& operator=(const DataAck& other);
    virtual DataAck *dup() const override {return new DataAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getUeId() const;
    virtual void setUeId(int ueId);

    virtual int getSequenceNumber() const;
    virtual void setSequenceNumber(int sequenceNumber);

    virtual bool getSuccess() const;
    virtual void setSuccess(bool success);

    virtual double getLatency() const;
    virtual void setLatency(double latency);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const DataAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, DataAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:64</tt> by opp_msgtool.
 * <pre>
 * // Phase 3: Network Optimization Messages
 * message MeasurementReport
 * {
 *     int ueId;
 *     int servingGNBId;
 *     double servingSignalStrength;
 *     int neighborGNBIds[];           // Array of neighbor gNB IDs
 *     double neighborSignalStrengths[]; // Signal strengths from neighbors
 *     double currentLoad;
 * }
 * </pre>
 */
class MeasurementReport : public ::omnetpp::cMessage
{
  protected:
    int ueId = 0;
    int servingGNBId = 0;
    double servingSignalStrength = 0;
    int *neighborGNBIds = nullptr;
    size_t neighborGNBIds_arraysize = 0;
    double *neighborSignalStrengths = nullptr;
    size_t neighborSignalStrengths_arraysize = 0;
    double currentLoad = 0;

  private:
    void copy(const MeasurementReport& other);

  protected:
    bool operator==(const MeasurementReport&) = delete;

  public:
    MeasurementReport(const char *name=nullptr, short kind=0);
    MeasurementReport(const MeasurementReport& other);
    virtual ~MeasurementReport();
    MeasurementReport& operator=(const MeasurementReport& other);
    virtual MeasurementReport *dup() const override {return new MeasurementReport(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getUeId() const;
    virtual void setUeId(int ueId);

    virtual int getServingGNBId() const;
    virtual void setServingGNBId(int servingGNBId);

    virtual double getServingSignalStrength() const;
    virtual void setServingSignalStrength(double servingSignalStrength);

    virtual void setNeighborGNBIdsArraySize(size_t size);
    virtual size_t getNeighborGNBIdsArraySize() const;
    virtual int getNeighborGNBIds(size_t k) const;
    virtual void setNeighborGNBIds(size_t k, int neighborGNBIds);
    virtual void insertNeighborGNBIds(size_t k, int neighborGNBIds);
    [[deprecated]] void insertNeighborGNBIds(int neighborGNBIds) {appendNeighborGNBIds(neighborGNBIds);}
    virtual void appendNeighborGNBIds(int neighborGNBIds);
    virtual void eraseNeighborGNBIds(size_t k);

    virtual void setNeighborSignalStrengthsArraySize(size_t size);
    virtual size_t getNeighborSignalStrengthsArraySize() const;
    virtual double getNeighborSignalStrengths(size_t k) const;
    virtual void setNeighborSignalStrengths(size_t k, double neighborSignalStrengths);
    virtual void insertNeighborSignalStrengths(size_t k, double neighborSignalStrengths);
    [[deprecated]] void insertNeighborSignalStrengths(double neighborSignalStrengths) {appendNeighborSignalStrengths(neighborSignalStrengths);}
    virtual void appendNeighborSignalStrengths(double neighborSignalStrengths);
    virtual void eraseNeighborSignalStrengths(size_t k);

    virtual double getCurrentLoad() const;
    virtual void setCurrentLoad(double currentLoad);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MeasurementReport& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MeasurementReport& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:74</tt> by opp_msgtool.
 * <pre>
 * message HandoverCommand
 * {
 *     int ueId;
 *     int sourceGNBId;
 *     int targetGNBId;
 *     int reason;                 // 0: signal, 1: load balancing
 * }
 * </pre>
 */
class HandoverCommand : public ::omnetpp::cMessage
{
  protected:
    int ueId = 0;
    int sourceGNBId = 0;
    int targetGNBId = 0;
    int reason = 0;

  private:
    void copy(const HandoverCommand& other);

  protected:
    bool operator==(const HandoverCommand&) = delete;

  public:
    HandoverCommand(const char *name=nullptr, short kind=0);
    HandoverCommand(const HandoverCommand& other);
    virtual ~HandoverCommand();
    HandoverCommand& operator=(const HandoverCommand& other);
    virtual HandoverCommand *dup() const override {return new HandoverCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getUeId() const;
    virtual void setUeId(int ueId);

    virtual int getSourceGNBId() const;
    virtual void setSourceGNBId(int sourceGNBId);

    virtual int getTargetGNBId() const;
    virtual void setTargetGNBId(int targetGNBId);

    virtual int getReason() const;
    virtual void setReason(int reason);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const HandoverCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, HandoverCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:82</tt> by opp_msgtool.
 * <pre>
 * message HandoverAck
 * {
 *     int ueId;
 *     int targetGNBId;
 *     bool success;
 * }
 * </pre>
 */
class HandoverAck : public ::omnetpp::cMessage
{
  protected:
    int ueId = 0;
    int targetGNBId = 0;
    bool success = false;

  private:
    void copy(const HandoverAck& other);

  protected:
    bool operator==(const HandoverAck&) = delete;

  public:
    HandoverAck(const char *name=nullptr, short kind=0);
    HandoverAck(const HandoverAck& other);
    virtual ~HandoverAck();
    HandoverAck& operator=(const HandoverAck& other);
    virtual HandoverAck *dup() const override {return new HandoverAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getUeId() const;
    virtual void setUeId(int ueId);

    virtual int getTargetGNBId() const;
    virtual void setTargetGNBId(int targetGNBId);

    virtual bool getSuccess() const;
    virtual void setSuccess(bool success);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const HandoverAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, HandoverAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:89</tt> by opp_msgtool.
 * <pre>
 * message LoadReport
 * {
 *     int gNBId;
 *     double currentLoad;         // Load percentage 0-100
 *     int connectedUEs;
 *     int availableRBs;
 *     double averageLatency;
 * }
 * </pre>
 */
class LoadReport : public ::omnetpp::cMessage
{
  protected:
    int gNBId = 0;
    double currentLoad = 0;
    int connectedUEs = 0;
    int availableRBs = 0;
    double averageLatency = 0;

  private:
    void copy(const LoadReport& other);

  protected:
    bool operator==(const LoadReport&) = delete;

  public:
    LoadReport(const char *name=nullptr, short kind=0);
    LoadReport(const LoadReport& other);
    virtual ~LoadReport();
    LoadReport& operator=(const LoadReport& other);
    virtual LoadReport *dup() const override {return new LoadReport(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getGNBId() const;
    virtual void setGNBId(int gNBId);

    virtual double getCurrentLoad() const;
    virtual void setCurrentLoad(double currentLoad);

    virtual int getConnectedUEs() const;
    virtual void setConnectedUEs(int connectedUEs);

    virtual int getAvailableRBs() const;
    virtual void setAvailableRBs(int availableRBs);

    virtual double getAverageLatency() const;
    virtual void setAverageLatency(double averageLatency);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LoadReport& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LoadReport& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:98</tt> by opp_msgtool.
 * <pre>
 * message LoadBalanceCommand
 * {
 *     int overloadedGNBId;
 *     int targetGNBId;
 *     int ueIdToMove;
 * }
 * </pre>
 */
class LoadBalanceCommand : public ::omnetpp::cMessage
{
  protected:
    int overloadedGNBId = 0;
    int targetGNBId = 0;
    int ueIdToMove = 0;

  private:
    void copy(const LoadBalanceCommand& other);

  protected:
    bool operator==(const LoadBalanceCommand&) = delete;

  public:
    LoadBalanceCommand(const char *name=nullptr, short kind=0);
    LoadBalanceCommand(const LoadBalanceCommand& other);
    virtual ~LoadBalanceCommand();
    LoadBalanceCommand& operator=(const LoadBalanceCommand& other);
    virtual LoadBalanceCommand *dup() const override {return new LoadBalanceCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getOverloadedGNBId() const;
    virtual void setOverloadedGNBId(int overloadedGNBId);

    virtual int getTargetGNBId() const;
    virtual void setTargetGNBId(int targetGNBId);

    virtual int getUeIdToMove() const;
    virtual void setUeIdToMove(int ueIdToMove);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LoadBalanceCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LoadBalanceCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/Messages.msg:106</tt> by opp_msgtool.
 * <pre>
 * // RIC Policy Messages
 * message PolicyUpdate
 * {
 *     int gNBId;
 *     double loadThreshold;
 *     double signalThreshold;
 *     bool enableLoadBalancing;
 *     bool enableHandover;
 * }
 * </pre>
 */
class PolicyUpdate : public ::omnetpp::cMessage
{
  protected:
    int gNBId = 0;
    double loadThreshold = 0;
    double signalThreshold = 0;
    bool enableLoadBalancing = false;
    bool enableHandover = false;

  private:
    void copy(const PolicyUpdate& other);

  protected:
    bool operator==(const PolicyUpdate&) = delete;

  public:
    PolicyUpdate(const char *name=nullptr, short kind=0);
    PolicyUpdate(const PolicyUpdate& other);
    virtual ~PolicyUpdate();
    PolicyUpdate& operator=(const PolicyUpdate& other);
    virtual PolicyUpdate *dup() const override {return new PolicyUpdate(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getGNBId() const;
    virtual void setGNBId(int gNBId);

    virtual double getLoadThreshold() const;
    virtual void setLoadThreshold(double loadThreshold);

    virtual double getSignalThreshold() const;
    virtual void setSignalThreshold(double signalThreshold);

    virtual bool getEnableLoadBalancing() const;
    virtual void setEnableLoadBalancing(bool enableLoadBalancing);

    virtual bool getEnableHandover() const;
    virtual void setEnableHandover(bool enableHandover);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PolicyUpdate& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PolicyUpdate& obj) {obj.parsimUnpack(b);}


namespace omnetpp {

template<> inline InitialAccessRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<InitialAccessRequest*>(ptr.get<cObject>()); }
template<> inline InitialAccessResponse *fromAnyPtr(any_ptr ptr) { return check_and_cast<InitialAccessResponse*>(ptr.get<cObject>()); }
template<> inline RegistrationRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<RegistrationRequest*>(ptr.get<cObject>()); }
template<> inline RegistrationResponse *fromAnyPtr(any_ptr ptr) { return check_and_cast<RegistrationResponse*>(ptr.get<cObject>()); }
template<> inline DataPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<DataPacket*>(ptr.get<cObject>()); }
template<> inline DataAck *fromAnyPtr(any_ptr ptr) { return check_and_cast<DataAck*>(ptr.get<cObject>()); }
template<> inline MeasurementReport *fromAnyPtr(any_ptr ptr) { return check_and_cast<MeasurementReport*>(ptr.get<cObject>()); }
template<> inline HandoverCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<HandoverCommand*>(ptr.get<cObject>()); }
template<> inline HandoverAck *fromAnyPtr(any_ptr ptr) { return check_and_cast<HandoverAck*>(ptr.get<cObject>()); }
template<> inline LoadReport *fromAnyPtr(any_ptr ptr) { return check_and_cast<LoadReport*>(ptr.get<cObject>()); }
template<> inline LoadBalanceCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<LoadBalanceCommand*>(ptr.get<cObject>()); }
template<> inline PolicyUpdate *fromAnyPtr(any_ptr ptr) { return check_and_cast<PolicyUpdate*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __MESSAGES_M_H

